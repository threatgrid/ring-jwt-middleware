[[https://travis-ci.org/threatgrid/ring-jwt-middleware][https://travis-ci.org/threatgrid/ring-jwt-middleware.png?branch=master]]

* ring-jwt-middleware

A simple middleware to authenticate users using JWT (JSON Web Tokens)
currently, only RS256 is supported.

** Features

- RS256 signing
- uses IANA "JSON Web Token Claims"
- JWT lifetime & Expiration support
- custom additional validation through a user provided functions
- custom revocation check through a user provided functions

** Usage


*** Example

#+begin_src clojure

(defn my-handler
  [request]
  ,,,)

(let [wrap-authentication
      (mk-wrap-authentication {:pubkey-path jwt-cert-path})]
  (wrap-authentication my-handler))
#+end_src

At this step the ~request~ passed to ~my-handler~ will have some of the following keys added:

- ~jwt~ => the claims of the JWT
- ~identity~ => the object representing the user identity constructed using JWT claims
- ~jwt-error~ => will contain an error object if the something went wrong with the JWT

The ~wrap-authentication~ will not take any decision about authorization access.
This lib also provide another helper to build another middleware handling
authorization.
You can inject your own authorization rules, via:

#+begin_src clojure
(let [wrap-authentication (mk-wrap-authentication
                           {:pubkey-path "/etc/secret/jwt.pub"
                            :is-revoked-fn my-revocation-check-fn
                            :jwt-check-fn my-jwt-checks})
      wrap-authorization (mk-wrap-authorization
                          {:no-jwt-handler my-middleware
                           :error-handler my-error-handler})]
  (wrap-authentication (wrap-authorization my-handler)))
#+end_src

**** Notes

There is a distinction between the ~:no-jwt~ error and the other one.
The main reason being that you should return an error in the ~error-handler~
while you could still accept un-authenticated access.

If you want to log the calls you should probably add a middleware after
authentication but before authorization.

*** Options

Notice you could add the following keys in the configuration passed to ~mk-wrap-authentication~:

1. ~is-revoked-fn~ ; given a decoded JWT should return true or false. If true
   the request return a 401. If not specified default to ~no-revocation-strategy~.
2. ~jwt-check-fn~ ; a function that takes two argument the raw JWT and the
   decoded JWT. This function should return a list of errors. If the list
   is empty, then the check is successful otherwise return throw a 401.

| Option                   | Description                                                                          | Default                        |
|--------------------------+--------------------------------------------------------------------------------------+--------------------------------|
| =:pubkey-path=             | the path to your public key                                                          | nil                            |
| =:pubkey-fn=               | A fn from claims to public key, has precedence over pubkey-path                      | nil                            |
| =:jwt-max-lifetime-in-sec= | set a max lifetime for JWTs to expire                                                | 86400                          |
| =:is-revoked-fn=           | a fn to checks if a given JWT should be revoked, should return bool                  | nil                            |
| =:jwt-check-fn=            | a fn to custom check the JWT, should return a vec of error strings or nil            | nil                            |
| =:no-jwt-handler=          | a middleware to pass when no JWT header is found  (=handler -> (request -> response)=) | forbid-no-jwt-header-strategy  |
| =:post-jwt-format-fn=      | a fn that given a JWT generate an identity information                               | jwt->user-id (the "sub" claim) |

By default if no JWT auth header is found the request is terminated with
=unauthorized= HTTP response.
You can use =authorize-no-jwt-header-strategy= for the =:no-jwt-handler= key if
you want to manage how to deal with that case in you own handler.
You could also provide your own middleware function for this case.

By default the ~:identity~ contains the ~"sub"~ field of the JWT. But you can
use more complex transformation. For example, there is a =jwt->oauth-ids=
function in the code that could be used to handle JWT generated from an OAuth2
provider.

*** JWT Format

Currently this middleware only supports JWT using claims registered in the IANA "JSON Web Token Claims",
which means you need to generate JWT using most of the claims described here: https://tools.ietf.org/html/rfc7519#section-4
namely =jti=, =exp=, =iat=, =nbf=,=sub=:

| Claim  | Description                                                        | Format |
|--------+--------------------------------------------------------------------+--------|
| =:exp= | Expiration time: https://tools.ietf.org/html/rfc7519#section-4.1.4 | Long   |
| =:iat= | Issued At: https://tools.ietf.org/html/rfc7519#section-4.1.6       | Long   |
| =:jti= | JWT ID: https://tools.ietf.org/html/rfc7519#section-4.1.7          | String |
| =:nbf= | Not Before: https://tools.ietf.org/html/rfc7519#section-4.1.5      | Long   |
| =:sub= | Subject: https://tools.ietf.org/html/rfc7519#section-4.1.2         | String |

here is a sample token:

#+BEGIN_SRC clojure
{:jti "r3e03ac6e-8d09-4d5e-8598-30e51a26cd2a"
 :exp 1499419023
 :iat 1498814223
 :nbf 1498813923
 :sub "f0010924-e1bc-4b03-b600-89c6cf52757c"

 :email "foo@bar.com"
 "http://example.com/claim/user/name" "john doe"}
#+END_SRC

** Generating Certs and a Token

A simple script is available to generate keys for signing the tokens:
=> ./resources/cert/gen_cert.sh=
some dummy ones are already available for easy testing.

- use =ring-jwt-middleware.core-test/make-jwt= to generate a sample token from a map

** License

Copyright Â© 2015-2021 Cisco Systems
Eclipse Public License v1.0
